\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}

\usepackage{graphicx}
\graphicspath{{src/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\usepackage{amsmath,amsfonts,amssymb,amsthm} 

% Для листинга кода:
\lstset{ %
language=c++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}


\begin{document}
\begin{titlepage}
	\centering
	{\scshape\LARGE МГТУ им. Баумана \par}
	\vspace{3cm}
	{\scshape\Large Рубежный контроль №1\par}
	\vspace{0.5cm}	
	{\scshape\Large По курсу: "Анализ алгоритмов"\par}
	\vspace{1.5cm}
	{\huge\bfseries Обход полного бинарного дерева в глубину\par}
	\vspace{2cm}
	\Large Работу выполнил: Гаврилов Дмитрий, ИУ7-56Б\par
	\vspace{0.5cm}
	\LargeПреподаватели:  Волкова Л.Л., Строганов Ю.В.\par

	\vfill
	\large \textit {Москва, 2019} \par
\end{titlepage}

\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}
Цель работы: изучение рекурсионоого и итерационного алгоритмов обхода полного бинарного дерева в глубину.  Также требуется оценить затраты по памяти и замерить время работы алгоритмов .


В ходе рубжного контроля предстоит решить следующие задачи:
\begin{itemize}
	\item изучить алгоритмы обхода дерева в глубину; 
	\item реализовать рекурсионный и итерационный алгоритмы на одном из языков программирования;  
	\item сравнить алгоритмы обхода дерева в глубину.
\end{itemize}



\chapter{Аналитическая часть}
Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы. Среди деревьев выделяют особый подкласс, называемый бинарными деревьями. Бинарное дерево - корневое дерево, каждая вершина которого имеет не более двух дочерних, чаще всего чётко упорядоченных: левую и правую. Среди бинарных деревьев отдельно выделяют полные бинарные деревья, все вершины которых имеют по две дочерних, кроме листьев, которые расположены на одинаковой глубине.
	    
\section{Поиск в глубину}
Поиск в глубину (англ. Depth-first search, DFS) — один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно.

\section{Рекурсивный алгоритм}
Перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину. Если после завершения алгоритма не все вершины были рассмотрены, то необходимо запустить алгоритм от одной из нерассмотренных вершин.

\section{Итеративный алгоритм}
Обрабатываем текущий узел, при наличии правого поддерева добавляем его в стек для последующей обработки. Переходим к узлу левого поддерева. Если левого узла нет, переходим к верхнему узлу из стека.

\section{Вывод}
Были рассмотрены алгоритмы обхода в глубину полного бинарного дерева.


\chapter{Технологическая часть}
\section{Выбор ЯП}
В качестве языка программирования был выбран Java \cite{Oracle}, а средой разработки Intellij IDEA. 
Время работы алгоритмов было замерено с помощью класса Instant.


\section{Сведения о модулях программы}
Программа состоит из:
\begin{itemize}
	\item Main.java - главный файл программы, в котором располагается точка входа в программу, реализации алгоритмов и функция замера времени.
\end{itemize}

\section{Листинг кода алгоритмов}
В листингах 3.1 - 3.2 будет рассмотрена реализация описанных алгоритмов.

\begin{lstlisting}[label=CodeStand,caption= Рекурсивный алгоритм обхода дерева в глубину]
public static int recDFS(Node root){
        if (root.left!=null) recDFS(root.left);
        if (root.right!=null) recDFS(root.right);

        return 0;
    }
\end{lstlisting}


\begin{lstlisting}[label=some-code,caption=Итерационный алгоритм обхода дерева в глубину]
public static int contDFS(Node top){
        Stack<Node> stack = new Stack<> ();
        while (top!=null || !stack.empty()){
            if (!stack.empty()){
                top=stack.pop();
            }
            while (top!=null){
                if (top.right!=null) stack.push(top.right);
                top=top.left;
            }
        }
        return 0;
    }
\end{lstlisting}




\chapter{Исследовательская часть}

\section{Сравнительный анализ на основе замеров времени работы алгоритмов}

Был проведен замер времени работы каждого из алгоритмов.

Эксперимент производится для полного бинарных деревьев размером от 5 до 25. 
Сравним результаты для разных алгоритмов:

\begin{tikzpicture}
\begin{axis}[
    	axis lines = left,
    	xlabel = {Размер дерева},
    	ylabel = {Время (нс)},
	legend pos=north west,
	ymajorgrids=true
]
\addplot[color=red, mark=square] table[x index=0, y index= 1] {src/rec.txt}; 
\addplot[color=green, mark=square] table[x index=0, y index= 1] {src/iter.txt}; 

\addlegendentry{Рекурсивный}
\addlegendentry{Итеративный}

\end{axis}
\end{tikzpicture}

\begin{center}
Pис. 4.1: Сравнение времени работы алгоритмов при разных размерах дерева
\end{center}

\section{Сравнительный анализ на основе замеров памяти алгоритмов}
Сравним потребление памяти алгоритмами при обходе дерева высотой 15.

Сравнительная таблица затрат по памяти.
\begin{center}
	\begin{tabular}{|c c c|} 
 	\hline
	Память & Рекурсивный алгоритм & Итерационный алгоритм \\ [0.5ex] 
 	\hline\hline
 	Потребляемая память & 40 * 15 & 80 + 40 * 15 \\
	\hline
	Итого & 600 & 680 \\
	\hline
	\end{tabular}
\end{center}
\section{Вывод}
По результатам тестирования времени на дереве высотой до 15 уровней алгоритмы продемонстрировали себя равно. С увеличением высоты дерева, рекурсивный алгоритм оказался быстрее.
По результатам сравнения затрат памяти слегка выигрывает рекурсивный алгоритм. Но стоит учитывать, что при обходе дерева большой высотой рекурсивным способом, может переполниться стек вызовов.



\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
В ходе рубежного контроля я изучил алгоритмы обхода полного бинарного дерева в глубину: рекурсиивный и итеративный, реализовал алгоритмы обхода дерева на языке программирования Java и сравнил эти алгоритмы.

\addcontentsline{toc}{chapter}{Список литературы}
 \begin{thebibliography}{3}
\bibitem{Beloysov}
И. В. Белоусов(2006), Матрицы и определители, учебное пособие по линейной алгебре, с. 1 - 16
\bibitem{Gall2012}
Le Gall, F. (2012), "Faster algorithms for rectangular matrix multiplication", Proceedings of the 53rd Annual IEEE Symposium on Foundations of Computer Science (FOCS 2012), pp. 514–523
%https://arxiv.org/pdf/1204.1111.pdf
\bibitem{Oracle Documentation}
Документация по языку Java[Электронный ресурс], - режим доступа: https://docs.oracle.com/en/java/javase/13/
\end{thebibliography}

\end{document}